use regex::Regex;
use strum::EnumIter;

use crate::contract::Contract;
use crate::report::Report;

#[derive(Debug, EnumIter)]
pub enum Vulnerability {
    Swc100,
}

pub trait Detector {
    fn detect(self: &Self, contract: &Contract) -> Report;
}

impl Detector for Vulnerability {
    fn detect(self: &Self, contract: &Contract) -> Report {
        match self {
            Vulnerability::Swc100 => {
                let function_regex = Regex::new(r"function \w+( )*\(.+\)").unwrap();
                let private_or_internal_regexp = Regex::new(r"private|internal").unwrap();
                let pure_or_view = Regex::new(r"pure|view").unwrap();

                // TODO: missing the case where the function is written into 2 lines (=2 items in the vec)
                let vuls: Vec<String> = contract
                    .verified_code
                    .as_ref()
                    .unwrap()
                    .iter()
                    .map(|item| item.1.to_owned())
                    .flatten()
                    .filter(|l| function_regex.is_match(l))
                    .filter(|l| !private_or_internal_regexp.is_match(l))
                    .filter(|l| !pure_or_view.is_match(l))
                    .collect();

                Report {
                    address: format!("{:?}", contract.address),
                    balance: format!(
                        "{} eth",
                        ethers::utils::format_units(contract.balance, "ether").unwrap()
                    ),
                    description: "Function Default Visibility".to_string(),
                    potential_threat: vuls,
                }
            }
        }
    }
}

#[cfg(test)]
mod test {
    use super::Detector;
    use crate::contract::Contract;
    use ethers::types::{H160, H256};
    use std::str::FromStr;
    use strum::IntoEnumIterator;

    use super::*;

    #[test]
    fn test_given_code_when_detect_then_expected_result() {
        let code_input = vec![
            ("Contract1.sol".to_owned(),
              vec![
                "// SPDX-License-Identifier: MIT".to_owned(),
                "".to_owned(),
                "abstract contract Context {".to_owned(),
                "// SPDX-License-Identifier: MIT".to_owned(),
                "// SPDX-License-Identifier: MIT".to_owned(),
              ],
            ),
            ("Contract2.sol".to_owned(), vec![
              "function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {".to_owned(),
              "".to_owned(),
              "abstract contract Context {".to_owned(),
              "\tfunction airDropMint(address _to, uint256 _quantity) external onlyOwner {".to_owned(),
              "\tfunction totalSupply() public returns (uint256) {".to_owned(),
            ],),
            ("Contract3.sol".to_owned(), vec!["\tfunction test() returns (uint256) {".to_owned()]),
        ];

        let mut contract = Contract::new_without_code(
            H160::from_str("0xac046563E7104292fe9130b08360049F79A3B5BF").unwrap(),
            ethers::utils::parse_ether("10.1").unwrap(),
            H256::from_str("0x043a718774c572bd8a25adbeb1bfcd5c0256ae11cecf9f9c3f925d0e52beaf89")
                .unwrap(),
        );
        contract.set_verified_code(code_input);

        let mut report = Report {
            address: "0xac046563E7104292fe9130b08360049F79A3B5BF".to_owned(),
            balance: "0".to_owned(),
            description: "".to_owned(),
            potential_threat: vec![],
        };

        for vul in Vulnerability::iter() {
            report = vul.detect(&contract);
        }

        assert_eq!(report.description, "Function Default Visibility");
        assert_eq!(report.potential_threat.len(), 3);
        assert_eq!(report.balance, "10.100000000000000000 eth".to_owned());
        assert_eq!(
            report.address,
            "0xac046563E7104292fe9130b08360049F79A3B5BF"
                .to_lowercase()
                .to_owned()
        );
    }
}
